% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MarkovitzRRR.R
\name{ParallelMarkovitzRRRCpp}
\alias{ParallelMarkovitzRRRCpp}
\alias{ParallelMarkovitzRRR}
\title{Compute Markovitz Optimal Portfolios via Reduced Rank Regression (RRR) in Parallel}
\usage{
ParallelMarkovitzRRR(
  returns,
  initial_solution = matrix(0, 0, 0),
  lambda1 = 0,
  lambda2_values = 0,
  penalty_type = "d",
  step_size_type = "d",
  step_size_constant = 0,
  max_iter = 10000,
  tolerance = 0,
  n_cores = parallel::detectCores() - 1,
  check_arguments = TRUE
)
}
\arguments{
\item{returns}{\verb{n_observations x n_returns}-dimensional matrix of centered(!)
test asset excess returns.}

\item{initial_solution}{\verb{n_returns x n_returns}-dimensional matrix of initial hedging weights.
Defaults to a hollow matrix with \code{1/N} as off-diagonal elements.
Default is \code{matrix(0, 0, 0)}.}

\item{lambda1}{a number indicating the penalty parameter associated
with the Nuclear penalty \verb{lambda1 * ||R * X||_*} or \verb{lambda1 * ||X||_*};
see \code{penalty_type}. If less than or equal to zero, optimization is carried on without this penalty.
default is \code{0}.}

\item{lambda2_values}{a vector of numbers indicating the multiple values of the
Ridge penalty parameter \verb{lambda2 * ||X||_F^2}. Each value of lambda2 is used in
a separate optimization problem solved in parallel. default is \code{0}.}

\item{penalty_type}{character indicating the type of penalty function: \code{'d'} for
default, i.e., penalty given by \verb{||RX||_*}; \code{'a'} for alternative, i.e., penalty
given by \verb{||X||_*}. Default is \code{'d'}.}

\item{step_size_type}{character indicating the type of step size: \code{'d'} for default,
i.e., not summable vanishing: \code{step_size_constant / sqrt(iter + 1)}; \code{'s'} for square
summable but not summable: \code{step_size_constant / (iter + 1)}; \code{'l'} for constant
step length: \verb{step_size_constant / ||subgradient||_F}; \code{'p'} for modified Polyak:
\verb{(step_size_constant + objective_iter - min\{objective_k | k=0,...,iter\}) / ||subgradient)||_F};
\code{'c'} for constant step size: \code{step_size_constant}. Default is \code{'d'}.}

\item{step_size_constant}{numeric constant determining the step size.
If zero or negative, it is internally set to \code{2./(min(sv(R))^2 + max(sv(R))^2 + lambda2)},
where \code{sv} denotes singular values. Default is \code{0}.}

\item{max_iter}{numeric solver parameter indicating the maximum number of iterations.
Default is \code{10000}.}

\item{tolerance}{numeric tolerance check for the Frobenious norm of successive
solutions \verb{||X_k+1 - X_k||_F / N}. If \code{tolerance > 0}, the solver stops when
\verb{||X_k+1 - X_k||_F / N <= tolerance}. If \code{tolerance <= 0}, no check is performed.
Default is \code{0}.}

\item{n_cores}{number of cores for parallel computation. Default is
\code{parallel::detectCores() - 1}, i.e., all available system cores minus one.}

\item{check_arguments}{boolean \code{TRUE} if you want to check function arguments;
\code{FALSE} otherwise. Default is \code{TRUE}.}
}
\value{
a list containing: the optimal solution in \verb{$solution};
the estimated precision matrix in \verb{$precision}; the optimal
value in \verb{$objective}; the optimal portfolio weights in \verb{$weights}; the number
of iterations in \verb{$iterations};
the solver status check (indicating if the objective value decreased from the
value at the initial value) in \verb{$is_improved}; the solver status
check (indicating if the objective value at the last solution equal to
the value at the best solution?) in \verb{$is_converged}.
}
\description{
This function computes Markovitz optimal portfolios via Reduced Rank
Regression approach in a parallel manner. It is designed to handle multiple values
of the Ridge penalty parameter (lambda2), solving the optimization problem for
each lambda2 value concurrently. The optimization problem is defined as:
minimize_X {0.5 ||R - RX||\emph{F^2 + lambda1 ||RX||}* + lambda2/2 ||X||_F^2 | diag(X) = 0}
or the alternative
minimize_X {0.5 ||R - RX||\emph{F^2 + lambda1 ||X||}* + lambda2/2 ||X||_F^2 | diag(X) = 0},
where ||.||\emph{F denotes the Frobenious norm and ||.||}* the Nuclear norm.
The function then calculates the optimal weights as:
\code{w = diag(Var[E])^(-1) * (I - X)}, where \code{E} is the residual in the regression R = RX + E.
}
\examples{
# Example usage with real data and multiple lambda2 values
returns = markovitzRRR::returns[1:200,-1]
lambda2_values = c(0.1, 0.2, 0.3)
# results = markovitzRRR::ParallelMarkovitzRRR(
#   returns,
#   initial_solution = matrix(0, 0, 0),
#   lambda1 = 0.1,
#   lambda2_values = lambda2_values
#)


}
